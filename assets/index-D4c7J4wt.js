(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const n of s)if(n.type==="childList")for(const a of n.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&i(a)}).observe(document,{childList:!0,subtree:!0});function t(s){const n={};return s.integrity&&(n.integrity=s.integrity),s.referrerPolicy&&(n.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?n.credentials="include":s.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(s){if(s.ep)return;s.ep=!0;const n=t(s);fetch(s.href,n)}})();class f{scene;baseTarget;towerTarget;enemies=new Map;enemyIdCounter=0;spawnInterval=null;gameLoop=null;health=100;points=0;gameOver=!1;gameWon=!1;healthElement=null;pointsElement=null;waveElement=null;upgradeScreen=null;blurElement=null;upgradePointsElement=null;restartButton=null;upgradeListElement=null;winPopup=null;winBlur=null;winRestartButton=null;winResetButton=null;winAttemptsElement=null;shopVisits=0;SHOP_VISITS_STORAGE_KEY="td_shop_visits";MOVEMENT_THRESHOLD=.3;STABILITY_TIME=2e3;TOWER_BASE_RANGE=700;TOWER_BASE_RADIUS=.7;towerFireRateMs=2e3;towerRange=this.TOWER_BASE_RANGE;towers=[];defaultBaseHealth=100;pointMultiplier=1;SPAWN_DISTANCE=5;MIN_SPAWN_TIME=10;GAME_Z_PLANE=0;spawnCount=0;spawnCenterAngle=0;currentWave=0;totalWaves=10;waveActive=!1;wavePaused=!1;enemiesSpawnedInWave=0;waveBreakDuration=5e3;pausedWaveConfig=null;pausedWaveCompleted=!1;waveConfig=[{count:5,baseSpeed:.3,spreadAngle:10,duration:5e3},{count:10,baseSpeed:.5,spreadAngle:30,duration:8e3},{count:15,baseSpeed:.75,spreadAngle:60,duration:1e4},{count:20,baseSpeed:1,spreadAngle:90,duration:1e4},{count:30,baseSpeed:1.2,spreadAngle:120,duration:1e4},{count:50,baseSpeed:1.5,spreadAngle:180,duration:12e3},{count:70,baseSpeed:2,spreadAngle:240,duration:12e3},{count:100,baseSpeed:2.5,spreadAngle:300,duration:15e3},{count:200,baseSpeed:3,spreadAngle:330,duration:2e4},{count:500,baseSpeed:4,spreadAngle:360,duration:3e4}];UPGRADE_STORAGE_KEY="td_upgrades";POINTS_STORAGE_KEY="td_points";upgradeDefs=[{id:"tower-count",name:"Tower Count",desc:"Add an additional tower",levels:[{value:1,cost:0},{value:2,cost:50},{value:3,cost:100}],format:e=>`${e}`},{id:"range",name:"Tower Range",desc:"Increase tower attack range",levels:[{value:1,cost:0},{value:1.1,cost:10},{value:1.2,cost:12},{value:1.4,cost:18},{value:1.7,cost:25},{value:2,cost:40},{value:2.5,cost:80},{value:3,cost:100}],format:e=>`x${e.toFixed(1)}`},{id:"fire-rate",name:"Tower Fire Rate",desc:"Reduce shooting cooldown",levels:[{value:2e3,cost:0},{value:1800,cost:5},{value:1600,cost:10},{value:1400,cost:20},{value:1200,cost:30},{value:1e3,cost:40},{value:800,cost:50},{value:500,cost:70},{value:300,cost:80},{value:200,cost:90},{value:100,cost:100}],format:e=>`${Math.round(e)}ms`},{id:"base-health",name:"Base Health",desc:"Increase base max health",levels:[{value:100,cost:0},{value:150,cost:10},{value:200,cost:20},{value:300,cost:30},{value:500,cost:50}],format:e=>`${e}`}];upgradeState={};constructor(){this.init()}init(){this.showDesktopPopupIfNeeded(),document.addEventListener("DOMContentLoaded",()=>{this.scene=document.querySelector("a-scene"),this.healthElement=document.getElementById("health-value"),this.pointsElement=document.getElementById("points-value"),this.waveElement=document.getElementById("wave-value"),this.upgradeScreen=document.getElementById("upgrade-screen"),this.blurElement=document.getElementById("blur"),this.upgradePointsElement=document.getElementById("upgrade-points"),this.upgradeListElement=document.getElementById("upgrade-list"),this.restartButton=document.getElementById("restart-btn"),this.winPopup=document.getElementById("win-popup"),this.winBlur=document.getElementById("win-blur"),this.winResetButton=document.getElementById("win-reset-btn"),this.winAttemptsElement=document.getElementById("win-attempts"),this.restartButton&&this.restartButton.addEventListener("click",()=>{this.restartGame()}),this.winRestartButton&&this.winRestartButton.addEventListener("click",()=>{this.hideWinPopup(),this.restartGame()}),this.winResetButton&&this.winResetButton.addEventListener("click",()=>{this.resetAllProgress()});const e=document.getElementById("help-btn"),t=document.getElementById("help-popup"),i=document.getElementById("close-help"),s=document.getElementById("help-blur");e&&t&&e.addEventListener("click",()=>{t.style.display="flex",s&&(s.style.display="block")}),i&&t&&i.addEventListener("click",()=>{t.style.display="none",s&&(s.style.display="none")}),s&&t&&s.addEventListener("click",()=>{t.style.display="none",s.style.display="none"}),this.loadUpgradeState(),this.loadPoints(),this.loadShopVisits(),this.applyUpgradeEffects(),this.scene.hasLoaded?this.setupGame():this.scene.addEventListener("loaded",()=>{this.setupGame()})})}showDesktopPopupIfNeeded(){const e=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),t=document.getElementById("desktop-popup"),i=document.getElementById("close-popup"),s=t?.querySelector("#blur");!e&&t&&(t.style.display="flex",s&&(s.style.display="block"),i&&i.addEventListener("click",()=>{t.style.display="none",s&&(s.style.display="none")}),s&&s.addEventListener("click",()=>{t.style.display="none",s.style.display="none"}))}setupGame(){if(this.baseTarget=document.querySelector('[mindar-image-target="targetIndex: 0"]'),this.towerTarget=document.querySelector('[mindar-image-target="targetIndex: 1"]'),!this.baseTarget||!this.towerTarget){console.error("Could not find base or tower targets");return}this.applyUpgradeEffects(),this.initializeTowersFromUpgrades(),console.log("Tower Defense Game initialized"),this.baseTarget.addEventListener("targetFound",()=>{this.startEnemySpawning()}),this.baseTarget.addEventListener("targetLost",()=>{this.stopEnemySpawning(!1)}),this.registerTowerEventListeners(),this.startGameLoop()}registerTowerEventListeners(){this.towers.forEach(e=>{e.target.addEventListener("targetFound",()=>{e.isMoving=!0,e.lastMovementTime=0,this.setupTowerVisualsForTower(e),e.homePosition=null}),e.target.addEventListener("targetLost",()=>{this.handleTowerLostForTower(e)})})}startEnemySpawning(){this.gameWon||(this.wavePaused&&this.currentWave>0?(this.wavePaused=!1,this.waveActive=!0,this.resumeWave()):this.currentWave===0&&(this.currentWave=1,this.startWave()))}initializeTowersFromUpgrades(){const e=this.upgradeState["tower-count"]??0,t=1+e,i=Array.from(document.querySelectorAll("a-entity.tower"));i.forEach((n,a)=>{const r=n;a<t?(r.setAttribute("visible","true"),r.object3D&&(r.object3D.visible=!0),n.querySelectorAll("*").forEach(o=>{o.setAttribute("visible","true"),o.object3D&&(o.object3D.visible=!0)}),n.hasAttribute("mindar-image-target")||r.setAttribute("mindar-image-target",`targetIndex: ${a+1}`)):(r.setAttribute("visible","false"),r.object3D&&(r.object3D.visible=!1),n.querySelectorAll("*").forEach(o=>{o.setAttribute("visible","false"),o.object3D&&(o.object3D.visible=!1)}),r.removeAttribute("mindar-image-target"))});const s=i.slice(0,t);this.towers=s.map(n=>({target:n,sphere:null,circle:null,movingText:null,homePosition:null,lastPosition:null,isMoving:!1,lastMovementTime:0,lastShotTime:0,fireRateMs:this.towerFireRateMs,range:this.towerRange})),console.log(`Initialized ${this.towers.length} tower(s) from upgrade level ${e}`)}reinitializeTowersAfterUpgrades(){this.towers.forEach(e=>{if(this.setTowerActiveForTower(e,!1),e.movingText){try{e.target.removeChild(e.movingText)}catch{}e.movingText=null}}),this.applyUpgradeEffects(),this.initializeTowersFromUpgrades(),this.towers.forEach(e=>{e.target.addEventListener("targetFound",()=>{this.setupTowerVisualsForTower(e),e.isMoving&&this.setTowerActiveForTower(e,!1),e.homePosition=null}),e.target.addEventListener("targetLost",()=>{this.handleTowerLostForTower(e)})})}resumeWave(){if(!this.pausedWaveConfig||this.currentWave===0)return;const e=this.pausedWaveConfig,t=Math.max(this.MIN_SPAWN_TIME,Math.round(e.duration/e.count)),i=this.pausedWaveCompleted;this.spawnInterval=window.setInterval(()=>{!this.waveActive||i||(this.enemiesSpawnedInWave<e.count?this.spawnEnemy():(clearInterval(this.spawnInterval),this.spawnInterval=null,this.waveActive=!1,this.pausedWaveConfig=null,console.log(`Wave ${this.currentWave} complete (${e.count} enemies spawned). Break for ${this.waveBreakDuration}ms...`),this.currentWave<this.totalWaves?setTimeout(()=>{this.currentWave++,this.startWave()},this.waveBreakDuration):console.log("All waves completed!")))},t),console.log(`Wave ${this.currentWave} resumed (${this.enemiesSpawnedInWave}/${e.count} spawned)`)}startWave(){if(this.currentWave>this.totalWaves||this.gameOver)return;const e=this.waveConfig[this.currentWave-1];this.waveActive=!0,this.enemiesSpawnedInWave=0,this.wavePaused=!1,this.pausedWaveCompleted=!1,this.pausedWaveConfig=e,this.spawnCenterAngle=Math.random()*Math.PI*2,console.log(`Wave ${this.currentWave} started: ${e.count} enemies`),this.spawnInterval&&clearInterval(this.spawnInterval);const t=Math.max(this.MIN_SPAWN_TIME,Math.round(e.duration/e.count));setTimeout(()=>{this.updateWaveDisplay()},2e3/e.baseSpeed);let i=!1;this.spawnInterval=window.setInterval(()=>{if(this.wavePaused){clearInterval(this.spawnInterval),this.spawnInterval=null,this.pausedWaveCompleted=i;return}!this.waveActive||i||(this.enemiesSpawnedInWave<e.count?this.spawnEnemy():i||(i=!0,clearInterval(this.spawnInterval),this.spawnInterval=null,this.waveActive=!1,this.pausedWaveConfig=null,console.log(`Wave ${this.currentWave} complete (${e.count} enemies spawned). Break for ${this.waveBreakDuration}ms...`),this.currentWave<this.totalWaves?setTimeout(()=>{this.currentWave++,this.startWave()},this.waveBreakDuration):console.log("All waves completed!")))},t)}stopEnemySpawning(e=!0){this.spawnInterval&&(clearInterval(this.spawnInterval),this.spawnInterval=null),e?(this.spawnCount=0,this.currentWave=0,this.waveActive=!1,this.wavePaused=!1,this.enemiesSpawnedInWave=0,this.pausedWaveConfig=null,console.log("Enemy spawning stopped and reset")):(this.waveActive=!1,this.wavePaused=!0,console.log(`Wave ${this.currentWave} paused (${this.enemiesSpawnedInWave} enemies spawned so far)`))}spawnEnemy(){if(this.gameOver||!this.waveActive||this.wavePaused)return;if(!this.isBaseVisible()){console.log("Base not visible, skipping enemy spawn");return}const e=`enemy-${this.enemyIdCounter++}`,t=document.createElement("a-sphere");t.setAttribute("id",e),t.setAttribute("radius","0.05"),t.setAttribute("color","#CCFF33"),t.setAttribute("roughness","1");const i=this.waveConfig[this.currentWave-1],s=i.spreadAngle*Math.PI/180,n=this.computeSpawnAngle(s),a=Math.cos(n)*this.SPAWN_DISTANCE,r=Math.sin(n)*this.SPAWN_DISTANCE;t.setAttribute("position",`${a} ${r} ${this.GAME_Z_PLANE}`),this.baseTarget.appendChild(t);const o=i.baseSpeed,h={id:e,entity:t,targetPosition:{x:0,y:0},speed:o,health:1};this.enemies.set(e,h),this.spawnCount++,this.enemiesSpawnedInWave++,console.log(`Spawned enemy ${e} at position (${a.toFixed(2)}, ${r.toFixed(2)}, 0) speed=${o.toFixed(2)} spreadAngle=${i.spreadAngle}Â°`)}computeSpawnAngle(e){if(e>=Math.PI*2-.001)return Math.random()*Math.PI*2;const t=(Math.random()-.5)*e;return this.spawnCenterAngle+t}updateTowerCooldownIndicators(){const e=Date.now();this.towers.forEach(t=>{if(!t.sphere)return;const i=e-t.lastShotTime;if(i<t.fireRateMs){const s=Math.max(0,Math.min(1,i/t.fireRateMs)),r=this.lerpColorHex("#330066","#6600FF",s);t.sphere.setAttribute("color",r)}else t.sphere.setAttribute("color","#6600FF")})}lerpColorHex(e,t,i){const s=e.replace(/^#/,""),n=t.replace(/^#/,""),a=parseInt(s.substring(0,2),16),r=parseInt(s.substring(2,4),16),o=parseInt(s.substring(4,6),16),h=parseInt(n.substring(0,2),16),g=parseInt(n.substring(2,4),16),p=parseInt(n.substring(4,6),16),d=Math.round(a+(h-a)*i),u=Math.round(r+(g-r)*i),c=Math.round(o+(p-o)*i),l=v=>v.toString(16).padStart(2,"0");return`#${l(d)}${l(u)}${l(c)}`}isBaseVisible(){return this.baseTarget&&this.baseTarget.object3D&&this.baseTarget.object3D.visible}startGameLoop(){const e=()=>{this.updateTowerCooldownIndicators(),this.updateEnemies(),this.gameLoop=requestAnimationFrame(e)};e()}updateEnemies(){if(this.gameOver||!this.isBaseVisible())return;const e=1/60;this.towers.forEach(t=>{this.isTowerVisible(t)&&this.isBaseVisible()&&this.checkTowerMovementForTower(t),t.isMoving||this.checkTowerAttacksForTower(t)}),this.enemies.forEach((t,i)=>{const s=t.entity.getAttribute("position"),n={x:t.targetPosition.x-s.x,y:t.targetPosition.y-s.y},a=Math.sqrt(n.x**2+n.y**2);if(a<.2){this.takeDamage(10),this.destroyEnemy(i),console.log(`Enemy ${i} reached the base! Health: ${this.health}`);return}const r={x:n.x/a,y:n.y/a},o={x:s.x+r.x*t.speed*e,y:s.y+r.y*t.speed*e,z:this.GAME_Z_PLANE};t.entity.setAttribute("position",`${o.x} ${o.y} ${o.z}`)}),this.checkWinCondition()}destroyEnemy(e){const t=this.enemies.get(e);t&&(t.entity.parentNode&&t.entity.parentNode.removeChild(t.entity),this.enemies.delete(e)),this.checkWinCondition()}isTowerVisible(e){return e.target&&e.target.object3D&&e.target.object3D.visible}getMarkerWorldPosition(e){if(!e||!e.object3D)return null;const t=e.object3D.getWorldPosition(new window.THREE.Vector3);return{x:t.x,y:t.y}}checkTowerAttacksForTower(e){if(!this.isTowerVisible(e))return;const t=Date.now();if(t-e.lastShotTime<e.fireRateMs)return;const i=this.getMarkerWorldPosition(e.target);if(!i)return;let s=null,n=Number.POSITIVE_INFINITY;if(this.enemies.forEach((a,r)=>{const o=this.getEnemyWorldPosition(a);if(o){const h=this.calculateDistance2D(i,o);h<=e.range&&h<n&&(n=h,s=r)}}),s){const a=this.enemies.get(s);a&&(this.createAttackLineFromTower(a,e),this.addPoints(1),this.destroyEnemy(s),e.lastShotTime=t)}}getEnemyWorldPosition(e){if(!e.entity||!e.entity.object3D)return null;const t=e.entity.object3D.getWorldPosition(new window.THREE.Vector3);return{x:t.x,y:t.y}}calculateDistance2D(e,t){const i=t.x-e.x,s=t.y-e.y;return Math.sqrt(i*i+s*s)}createAttackLineFromTower(e,t){const i=e.entity.getAttribute("position"),s=this.getTowerPositionForTower(t);if(!s)return;const n=document.createElement("a-entity"),a=Math.sqrt((i.x-s.x)**2+(i.y-s.y)**2),r=Math.atan2(i.y-s.y,i.x-s.x),o={x:(s.x+i.x)/2,y:(s.y+i.y)/2,z:this.GAME_Z_PLANE+.01};n.setAttribute("geometry",`primitive: cylinder; radius: 0.005; height: ${a}`),n.setAttribute("material","color: #F8349B; opacity: 0.5"),n.setAttribute("position",`${o.x} ${o.y} ${o.z}`),n.setAttribute("rotation",`0 0 ${r*180/Math.PI-90}`),this.baseTarget.appendChild(n),setTimeout(()=>{n.parentNode&&n.parentNode.removeChild(n)},100)}setupTowerVisualsForTower(e){e.target&&(e.sphere=e.target.querySelector("a-sphere")||e.target.querySelector("a-box")||e.target.querySelector("a-cone")||e.target.querySelector("a-tetrahedron"),e.circle=e.target.querySelector("a-circle"),this.setTowerActiveForTower(e,!1))}handleTowerLostForTower(e){if(e.movingText&&e.target)try{e.target.removeChild(e.movingText)}catch{console.log("Could not remove moving text (target already lost)")}e.isMoving=!0,this.resetTowerStateForTower(e)}resetTowerStateForTower(e){e.sphere=null,e.circle=null,e.movingText=null,e.homePosition=null,e.lastPosition=null,e.lastMovementTime=Date.now()}checkTowerMovementForTower(e){const t=this.getTowerPositionForTower(e);if(!t)return;const i=Date.now();if(!e.homePosition){e.homePosition={...t},e.lastMovementTime=i;return}const s=this.calculateDistance2D(e.homePosition,t);let n=0;if(e.lastPosition&&(n=this.calculateDistance2D(e.lastPosition,t)),s>this.MOVEMENT_THRESHOLD&&!e.isMoving&&(e.isMoving=!0,this.setTowerActiveForTower(e,!1),e.circle&&e.circle.setAttribute("color","#000000"),e.lastMovementTime=0),e.isMoving){if(e.circle||(e.circle=e.target.querySelector("a-circle")),e.circle){e.circle.setAttribute("color","#000000");const a=this.towerRange/this.TOWER_BASE_RANGE,r=this.TOWER_BASE_RADIUS*a;e.circle.setAttribute("radius",r.toString())}if(n<=.1){e.lastMovementTime===0&&(e.lastMovementTime=i);const a=i-e.lastMovementTime,r=this.STABILITY_TIME-a;a>=this.STABILITY_TIME?(e.homePosition={...t},e.isMoving=!1,e.circle&&e.circle.setAttribute("color","#6600FF"),this.setTowerActiveForTower(e,!0),e.lastMovementTime=0):this.updateMovingText(Math.ceil(100-r/this.STABILITY_TIME*100)+"%")}else e.lastMovementTime>0&&(e.lastMovementTime=0)}e.lastPosition={...t}}updateMovingText(e){this.towers.forEach(t=>{t.movingText&&t.movingText.setAttribute("value",`BUILDING... (${e})`)})}setTowerActiveForTower(e,t){e.target&&(e.sphere||(e.sphere=e.target.querySelector("a-sphere")||e.target.querySelector("a-box")||e.target.querySelector("a-cone")||e.target.querySelector("a-tetrahedron")),t?(e.sphere&&(e.sphere.setAttribute("visible","true"),e.sphere.setAttribute("opacity","1")),e.circle&&!e.isMoving&&e.circle.setAttribute("color","#6600FF"),e.movingText&&(e.target.removeChild(e.movingText),e.movingText=null)):(e.sphere&&(e.sphere.setAttribute("visible","false"),e.sphere.setAttribute("opacity","0")),e.circle&&!e.isMoving&&e.circle.setAttribute("color","#330066"),e.movingText||(e.movingText=document.createElement("a-text"),e.movingText.setAttribute("position","0 0 0.15"),e.movingText.setAttribute("align","center"),e.movingText.setAttribute("color","white"),e.movingText.setAttribute("scale","0.5 0.5 0.5"),e.target.appendChild(e.movingText))))}getTowerPositionForTower(e){if(!this.baseTarget||!e.target||!this.baseTarget.object3D||!e.target.object3D)return null;const t=e.target.object3D.getWorldPosition(new window.THREE.Vector3),i=this.baseTarget.object3D.worldToLocal(t.clone());return{x:i.x,y:i.y}}takeDamage(e){if(!this.gameOver&&(this.health-=e,this.health=Math.max(0,this.health),this.updateHealthDisplay(),this.baseTarget)){const t=this.baseTarget.querySelector("a-icosahedron");t&&(t.setAttribute("color","#F8349B"),setTimeout(()=>{t.setAttribute("color","white")},100)),this.health<=0&&(t?.setAttribute("color","white"),this.endGame())}}addPoints(e){if(this.gameOver)return;const t=Math.round(e*this.pointMultiplier);this.points+=t,this.savePoints(),this.updatePointsDisplay()}updateHealthDisplay(){this.healthElement&&(this.healthElement.textContent=this.health.toString(),this.health<=30?this.healthElement.classList.add("low"):this.healthElement.classList.remove("low"))}updatePointsDisplay(){this.pointsElement&&(this.pointsElement.textContent=this.points.toString()),this.upgradePointsElement&&(this.upgradePointsElement.textContent=this.points.toString())}updateWaveDisplay(){this.waveElement&&(this.waveElement.textContent=this.currentWave.toString())}checkWinCondition(){if(this.gameWon||!(this.currentWave===this.totalWaves&&this.currentWave>0))return;const t=this.waveConfig[this.totalWaves-1];this.enemiesSpawnedInWave>=t.count&&this.spawnInterval===null&&!this.waveActive&&!this.wavePaused&&this.enemies.size===0&&this.handleWin()}handleWin(){this.gameWon=!0,this.gameOver=!0,this.waveActive=!1,this.wavePaused=!1,this.stopEnemySpawning(!1),this.upgradeScreen&&(this.upgradeScreen.style.display="none"),this.blurElement&&(this.blurElement.style.display="none");const e=this.shopVisits+1;this.winAttemptsElement&&(this.winAttemptsElement.textContent=`Attempts to win: ${e}`),this.winPopup&&(this.winPopup.style.display="flex"),this.winBlur&&(this.winBlur.style.display="block")}endGame(){this.gameOver=!0,this.recordShopVisit(),this.stopEnemySpawning(),this.upgradeScreen&&this.upgradePointsElement&&this.blurElement&&(this.upgradePointsElement.textContent=this.points.toString(),this.upgradeScreen.style.display="block",this.blurElement.style.display="block",this.renderUpgradeUI()),this.towers.forEach(e=>{if(e.movingText){try{e.target.removeChild(e.movingText)}catch{}e.movingText=null}})}restartGame(){this.stopEnemySpawning(!0),this.health=this.defaultBaseHealth,this.points=0,this.savePoints(),this.gameOver=!1,this.gameWon=!1,this.enemies.forEach((e,t)=>{this.destroyEnemy(t)}),this.enemyIdCounter=0,this.currentWave=0,this.waveActive=!1,this.wavePaused=!1,this.enemiesSpawnedInWave=0,this.spawnCount=0,this.pausedWaveConfig=null,this.pausedWaveCompleted=!1,this.updateHealthDisplay(),this.updatePointsDisplay(),this.updateWaveDisplay(),this.upgradeScreen&&(this.upgradeScreen.style.display="none"),this.blurElement&&(this.blurElement.style.display="none"),this.hideWinPopup(),this.reinitializeTowersAfterUpgrades(),this.baseTarget?.object3D?.visible&&this.startEnemySpawning(),console.log("Game restarted!")}resetAllProgress(){try{window.localStorage.removeItem(this.UPGRADE_STORAGE_KEY),window.localStorage.removeItem(this.POINTS_STORAGE_KEY),window.localStorage.removeItem(this.SHOP_VISITS_STORAGE_KEY)}catch{}window.location.reload()}hideWinPopup(){this.winPopup&&(this.winPopup.style.display="none"),this.winBlur&&(this.winBlur.style.display="none")}loadUpgradeState(){try{const e=window.localStorage.getItem(this.UPGRADE_STORAGE_KEY);e?this.upgradeState=JSON.parse(e):(this.upgradeState=this.upgradeDefs.reduce((t,i)=>(t[i.id]=0,t),{}),this.saveUpgradeState())}catch{this.upgradeState={},this.upgradeDefs.forEach(e=>this.upgradeState[e.id]=0)}}saveUpgradeState(){try{window.localStorage.setItem(this.UPGRADE_STORAGE_KEY,JSON.stringify(this.upgradeState))}catch{}}loadPoints(){try{const e=window.localStorage.getItem(this.POINTS_STORAGE_KEY);e&&(this.points=parseInt(e,10),this.updatePointsDisplay())}catch{this.points=0}}loadShopVisits(){try{const e=window.localStorage.getItem(this.SHOP_VISITS_STORAGE_KEY);e&&(this.shopVisits=parseInt(e,10)||0)}catch{this.shopVisits=0}}saveShopVisits(){try{window.localStorage.setItem(this.SHOP_VISITS_STORAGE_KEY,this.shopVisits.toString())}catch{}}savePoints(){try{window.localStorage.setItem(this.POINTS_STORAGE_KEY,this.points.toString())}catch{}}recordShopVisit(){this.shopVisits+=1,this.saveShopVisits()}getUpgradeCurrentValueById(e){const t=this.upgradeDefs.find(i=>i.id===e);return t?this.getUpgradeCurrentValue(t):0}applyUpgradeEffects(){const e=this.getUpgradeCurrentValueById("range");this.towerRange=this.TOWER_BASE_RANGE*e,this.towerFireRateMs=this.getUpgradeCurrentValueById("fire-rate"),this.defaultBaseHealth=this.getUpgradeCurrentValueById("base-health"),this.towers.forEach(t=>{t.range=this.towerRange,t.fireRateMs=this.towerFireRateMs;const i=this.TOWER_BASE_RADIUS*e;t.circle&&t.circle.setAttribute("radius",i)}),this.health=this.defaultBaseHealth,this.updateHealthDisplay()}getUpgradeCurrentValue(e){const t=this.upgradeState[e.id]??0;return e.levels[Math.min(t,e.levels.length-1)].value}getUpgradeNextValue(e){const t=(this.upgradeState[e.id]??0)+1,i=Math.min(t,e.levels.length-1);return e.levels[i].value}getUpgradeNextCost(e){const t=(this.upgradeState[e.id]??0)+1;return t>=e.levels.length?0:e.levels[t].cost}renderUpgradeUI(){if(!this.upgradeListElement)return;const e=this.upgradeListElement;e.innerHTML="",this.upgradeDefs.forEach(t=>{const i=this.getUpgradeCurrentValue(t),s=this.getUpgradeNextValue(t),n=this.getUpgradeNextCost(t),a=this.upgradeState[t.id]??0,r=a>=t.levels.length-1,o=t.levels.length,h=r?"Max":t.format(s),g=r?"Max":`<span class="material-symbols-rounded icon-bolt-small">bolt</span><span class="cost-value">${n}</span>`;let p='<div class="upgrade-progress">';for(let c=1;c<o;c++){const l=c<=a?"filled":"";p+=`<div class="progress-segment ${l}"></div>`}p+="</div>";const d=document.createElement("div");d.className="upgrade-item",d.innerHTML=`
        <div class="upgrade-header">
          <span class="upgrade-name">${t.name}</span>
          <span class="upgrade-cost">${g}</span>
        </div>
        <p class="upgrade-desc">${t.desc}</p>
        <p class="upgrade-level"><span class="level-current">${t.format(i)}</span> <span class="material-symbols-rounded icon-to">arrow_right</span> <span class="level-next">${h}</span></p>
        ${p}
        <button class="upgrade-btn" data-upgrade="${t.id}">Upgrade</button>
      `;const u=d.querySelector(".upgrade-btn");if(u){let c="Upgrade",l=!1;r?(c="Max",l=!0):this.points<n&&(c="Not enough points",l=!0),u.textContent=c,l?u.setAttribute("disabled","true"):u.removeAttribute("disabled"),u.addEventListener("click",()=>{l||this.purchaseUpgrade(t.id,n)})}e.appendChild(d)})}purchaseUpgrade(e,t){if(this.points<t){console.warn(`Not enough points for ${e}`);return}this.points-=t,this.savePoints(),this.updatePointsDisplay(),this.upgradeState[e]=(this.upgradeState[e]??0)+1,this.saveUpgradeState(),this.applyUpgradeEffects(),this.renderUpgradeUI(),e==="tower-count"&&this.reinitializeTowersAfterUpgrades(),console.log(`Purchased ${e} to level ${this.upgradeState[e]}`)}cleanup(){this.spawnInterval&&clearInterval(this.spawnInterval),this.gameLoop&&cancelAnimationFrame(this.gameLoop),this.enemies.forEach((e,t)=>{this.destroyEnemy(t)})}}const y=new f;window.addEventListener("beforeunload",()=>{y.cleanup()});
