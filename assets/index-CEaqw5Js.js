(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const o of n.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(i){if(i.ep)return;i.ep=!0;const n=t(i);fetch(i.href,n)}})();class T{scene;baseTarget;towerTarget;enemies=new Map;enemyIdCounter=0;spawnInterval=null;gameLoop=null;health=100;points=0;gameOver=!1;healthElement=null;pointsElement=null;gameOverScreen=null;finalScoreElement=null;restartButton=null;towerSphere=null;towerCircle=null;towerMovingText=null;towerHomePosition=null;lastTowerPosition=null;towerIsMoving=!1;lastMovementTime=0;MOVEMENT_THRESHOLD=.3;STABILITY_TIME=4e3;lastShotTime=0;towerFireRateMs=3e3;towerRange=1e3;defaultBaseHealth=100;pointMultiplier=1;SPAWN_DISTANCE=5;SPAWN_TIME=3e3;MIN_SPAWN_TIME=100;SPAWN_RATE_DECREASE_TIME=180;GAME_Z_PLANE=0;spawnStartTime=null;spawnCount=0;spawnCenterAngle=0;INITIAL_SPAWN_SPREAD=Math.PI/6;SPAWN_SPREAD_GROWTH_TIME=120;MAX_SPAWN_SPREAD=Math.PI*2;INITIAL_ENEMY_SPEED=.3;MAX_ENEMY_SPEED=1.5;ENEMY_SPEED_GROWTH_TIME=180;currentSpawnIntervalMs=null;constructor(){this.init()}init(){document.addEventListener("DOMContentLoaded",()=>{this.scene=document.querySelector("a-scene"),this.healthElement=document.getElementById("health-value"),this.pointsElement=document.getElementById("points-value"),this.gameOverScreen=document.getElementById("game-over-screen"),this.finalScoreElement=document.getElementById("final-score"),this.restartButton=document.getElementById("restart-btn"),this.restartButton&&this.restartButton.addEventListener("click",()=>{this.restartGame()}),this.scene.hasLoaded?this.setupGame():this.scene.addEventListener("loaded",()=>{this.setupGame()})})}setupGame(){if(this.baseTarget=document.querySelector('[mindar-image-target="targetIndex: 0"]'),this.towerTarget=document.querySelector('[mindar-image-target="targetIndex: 1"]'),!this.baseTarget||!this.towerTarget){console.error("Could not find base or tower targets");return}console.log("Tower Defense Game initialized"),this.baseTarget.addEventListener("targetFound",()=>{this.startEnemySpawning()}),this.baseTarget.addEventListener("targetLost",()=>{this.stopEnemySpawning(!1)}),this.towerTarget.addEventListener("targetFound",()=>{this.setupTowerVisuals(),this.towerIsMoving&&this.setTowerActive(!1),this.towerHomePosition=null}),this.towerTarget.addEventListener("targetLost",()=>{this.handleTowerLost()}),this.startGameLoop()}startEnemySpawning(){if(this.spawnInterval)return;this.spawnStartTime||(this.spawnStartTime=Date.now(),this.spawnCount=0,this.spawnCenterAngle=Math.random()*Math.PI*2);const e=this.spawnStartTime?(Date.now()-this.spawnStartTime)/1e3:0,t=Math.max(this.MIN_SPAWN_TIME,Math.round(this.computeSpawnIntervalMs(e)));this.currentSpawnIntervalMs=t,this.spawnInterval=window.setInterval(()=>{this.spawnEnemy()},t)}stopEnemySpawning(e=!0){this.spawnInterval&&(clearInterval(this.spawnInterval),this.spawnInterval=null,this.currentSpawnIntervalMs=null,e&&(this.spawnStartTime=null,this.spawnCount=0),console.log("Enemy spawning stopped"))}spawnEnemy(){if(this.gameOver)return;if(!this.isBaseVisible()){console.log("Base not visible, skipping enemy spawn");return}const e=`enemy-${this.enemyIdCounter++}`,t=document.createElement("a-sphere");t.setAttribute("id",e),t.setAttribute("radius","0.05"),t.setAttribute("color","lime"),t.setAttribute("roughness","1");const s=this.spawnStartTime?(Date.now()-this.spawnStartTime)/1e3:0,i=this.computeSpawnSpread(s),n=this.computeSpawnAngle(i),o=Math.cos(n)*this.SPAWN_DISTANCE,r=Math.sin(n)*this.SPAWN_DISTANCE;t.setAttribute("position",`${o} ${r} ${this.GAME_Z_PLANE}`),this.baseTarget.appendChild(t);const a=this.computeEnemySpeed(s),h={id:e,entity:t,targetPosition:{x:0,y:0},speed:a,health:1};this.enemies.set(e,h),this.spawnCount++,this.updateSpawnInterval(s),console.log(`Spawned enemy ${e} at position (${o.toFixed(2)}, ${r.toFixed(2)}, 0) speed=${a.toFixed(2)} spread=${i.toFixed(2)}`)}computeSpawnSpread(e){const t=Math.min(1,e/this.SPAWN_SPREAD_GROWTH_TIME);return this.INITIAL_SPAWN_SPREAD+t*(this.MAX_SPAWN_SPREAD-this.INITIAL_SPAWN_SPREAD)}computeSpawnAngle(e){if(e>=Math.PI*2-.001)return Math.random()*Math.PI*2;const t=(Math.random()-.5)*e;return this.spawnCenterAngle+t}computeEnemySpeed(e){const t=Math.min(1,e/this.ENEMY_SPEED_GROWTH_TIME);return this.INITIAL_ENEMY_SPEED+t*(this.MAX_ENEMY_SPEED-this.INITIAL_ENEMY_SPEED)}computeSpawnIntervalMs(e){const t=Math.min(1,e/this.SPAWN_RATE_DECREASE_TIME),s=this.SPAWN_TIME,i=this.MIN_SPAWN_TIME;return s-t*(s-i)}updateSpawnInterval(e){if(!this.spawnInterval)return;const t=Math.max(this.MIN_SPAWN_TIME,Math.round(this.computeSpawnIntervalMs(e)));(this.currentSpawnIntervalMs===null||t!==this.currentSpawnIntervalMs)&&(clearInterval(this.spawnInterval),this.spawnInterval=window.setInterval(()=>{this.spawnEnemy()},t),this.currentSpawnIntervalMs=t,console.log(`Adjusted spawn interval to ${t}ms`))}updateTowerCooldownIndicator(){if(!this.towerSphere)return;const t=Date.now()-this.lastShotTime;if(t<this.towerFireRateMs){const s=Math.max(0,Math.min(1,t/this.towerFireRateMs)),o=this.lerpColorHex("#aaaaaa","#ff0000",s);this.towerSphere.setAttribute("color",o)}else this.towerSphere.setAttribute("color","#ff0000")}lerpColorHex(e,t,s){const i=e.replace(/^#/,""),n=t.replace(/^#/,""),o=parseInt(i.substring(0,2),16),r=parseInt(i.substring(2,4),16),a=parseInt(i.substring(4,6),16),h=parseInt(n.substring(0,2),16),u=parseInt(n.substring(2,4),16),w=parseInt(n.substring(4,6),16),m=Math.round(o+(h-o)*s),d=Math.round(r+(u-r)*s),p=Math.round(a+(w-a)*s),l=g=>g.toString(16).padStart(2,"0");return`#${l(m)}${l(d)}${l(p)}`}isBaseVisible(){return this.baseTarget&&this.baseTarget.object3D&&this.baseTarget.object3D.visible}startGameLoop(){const e=()=>{this.updateTowerCooldownIndicator(),this.updateEnemies(),this.gameLoop=requestAnimationFrame(e)};e()}updateEnemies(){if(this.gameOver||!this.isBaseVisible())return;const e=1/60;this.isTowerVisible()&&this.isBaseVisible()&&this.checkTowerMovement(),this.towerIsMoving||this.checkTowerAttacks(),this.enemies.forEach((t,s)=>{const i=t.entity.getAttribute("position"),n={x:t.targetPosition.x-i.x,y:t.targetPosition.y-i.y},o=Math.sqrt(n.x**2+n.y**2);if(o<.2){this.takeDamage(10),this.destroyEnemy(s),console.log(`Enemy ${s} reached the base! Health: ${this.health}`);return}const r={x:n.x/o,y:n.y/o},a={x:i.x+r.x*t.speed*e,y:i.y+r.y*t.speed*e,z:this.GAME_Z_PLANE};t.entity.setAttribute("position",`${a.x} ${a.y} ${a.z}`)})}destroyEnemy(e){const t=this.enemies.get(e);t&&(t.entity.parentNode&&t.entity.parentNode.removeChild(t.entity),this.enemies.delete(e))}isTowerVisible(){return this.towerTarget&&this.towerTarget.object3D&&this.towerTarget.object3D.visible}getMarkerWorldPosition(e){if(!e||!e.object3D)return null;const t=e.object3D.getWorldPosition(new window.THREE.Vector3);return{x:t.x,y:t.y}}checkTowerAttacks(){if(!this.isTowerVisible())return;const e=Date.now();if(e-this.lastShotTime<this.towerFireRateMs)return;const t=this.getMarkerWorldPosition(this.towerTarget);if(!t)return;let s=null,i=Number.POSITIVE_INFINITY;if(this.enemies.forEach((n,o)=>{const r=this.getEnemyWorldPosition(n);if(r){const a=this.calculateDistance2D(t,r);a<=this.towerRange&&a<i&&(i=a,s=o)}}),s){const n=this.enemies.get(s);n&&(this.createAttackLine(n),this.addPoints(1),this.destroyEnemy(s),this.lastShotTime=e)}}getEnemyWorldPosition(e){if(!e.entity||!e.entity.object3D)return null;const t=e.entity.object3D.getWorldPosition(new window.THREE.Vector3);return{x:t.x,y:t.y}}calculateDistance2D(e,t){const s=t.x-e.x,i=t.y-e.y;return Math.sqrt(s*s+i*i)}createAttackLine(e){const t=e.entity.getAttribute("position"),s=this.getTowerPosition();if(!s)return;const i=document.createElement("a-entity"),n=Math.sqrt((t.x-s.x)**2+(t.y-s.y)**2),o=Math.atan2(t.y-s.y,t.x-s.x),r={x:(s.x+t.x)/2,y:(s.y+t.y)/2,z:this.GAME_Z_PLANE+.01};i.setAttribute("geometry",`primitive: cylinder; radius: 0.005; height: ${n}`),i.setAttribute("material","color: #ff0000; opacity: 0.5"),i.setAttribute("position",`${r.x} ${r.y} ${r.z}`),i.setAttribute("rotation",`0 0 ${o*180/Math.PI-90}`),this.baseTarget.appendChild(i),setTimeout(()=>{i.parentNode&&i.parentNode.removeChild(i)},100)}setupTowerVisuals(){this.towerTarget&&(this.towerSphere=this.towerTarget.querySelector("a-sphere"),this.towerCircle=this.towerTarget.querySelector("a-circle"),this.setTowerActive(!0))}handleTowerLost(){if(this.towerMovingText&&this.towerTarget)try{this.towerTarget.removeChild(this.towerMovingText)}catch{console.log("Could not remove moving text (target already lost)")}this.towerIsMoving=!0,this.resetTowerState()}resetTowerState(){this.towerSphere=null,this.towerCircle=null,this.towerMovingText=null,this.towerHomePosition=null,this.lastTowerPosition=null,this.lastMovementTime=Date.now()}checkTowerMovement(){const e=this.getTowerPosition();if(!e)return;const t=Date.now();if(!this.towerHomePosition){this.towerHomePosition={...e},this.lastMovementTime=t;return}const s=this.calculateDistance2D(this.towerHomePosition,e);let i=0;if(this.lastTowerPosition&&(i=this.calculateDistance2D(this.lastTowerPosition,e)),s>this.MOVEMENT_THRESHOLD&&!this.towerIsMoving&&(this.towerIsMoving=!0,this.setTowerActive(!1),this.lastMovementTime=0),this.towerIsMoving)if(i<=.1){this.lastMovementTime===0&&(this.lastMovementTime=t);const n=t-this.lastMovementTime,o=this.STABILITY_TIME-n;n>=this.STABILITY_TIME?(this.towerHomePosition={...e},this.towerIsMoving=!1,this.setTowerActive(!0),this.lastMovementTime=0):this.updateMovingText(Math.ceil(o/1e3))}else this.lastMovementTime>0&&(this.lastMovementTime=0);this.lastTowerPosition={...e}}updateMovingText(e){this.towerMovingText&&(e==this.STABILITY_TIME/1e3?this.towerMovingText.setAttribute("value","BUILDING..."):this.towerMovingText.setAttribute("value",`BUILDING... (${e})`))}setTowerActive(e){this.towerTarget&&(e?(this.towerSphere&&this.towerSphere.setAttribute("visible","true"),this.towerCircle&&this.towerCircle.setAttribute("color","red"),this.towerMovingText&&(this.towerTarget.removeChild(this.towerMovingText),this.towerMovingText=null)):(this.towerSphere&&this.towerSphere.setAttribute("visible","false"),this.towerCircle&&this.towerCircle.setAttribute("color","black"),this.towerMovingText||(this.towerMovingText=document.createElement("a-text"),this.towerMovingText.setAttribute("position","0 0 0.15"),this.towerMovingText.setAttribute("align","center"),this.towerMovingText.setAttribute("color","white"),this.towerMovingText.setAttribute("scale","0.5 0.5 0.5"),this.towerTarget.appendChild(this.towerMovingText))))}getTowerPosition(){if(!this.baseTarget||!this.towerTarget||!this.baseTarget.object3D||!this.towerTarget.object3D)return null;const e=this.towerTarget.object3D.getWorldPosition(new window.THREE.Vector3),t=this.baseTarget.object3D.worldToLocal(e.clone());return{x:t.x,y:t.y}}takeDamage(e){this.gameOver||(this.health-=e,this.health=Math.max(0,this.health),this.updateHealthDisplay(),this.health<=0&&this.endGame())}addPoints(e){if(this.gameOver)return;const t=Math.round(e*this.pointMultiplier);this.points+=t,this.updatePointsDisplay()}updateHealthDisplay(){this.healthElement&&(this.healthElement.textContent=this.health.toString(),this.health<=30?this.healthElement.classList.add("low"):this.healthElement.classList.remove("low"))}updatePointsDisplay(){this.pointsElement&&(this.pointsElement.textContent=this.points.toString())}endGame(){this.gameOver=!0,this.stopEnemySpawning(),this.gameOverScreen&&this.finalScoreElement&&(this.finalScoreElement.textContent=this.points.toString(),this.gameOverScreen.style.display="block"),this.towerMovingText&&(this.towerTarget.removeChild(this.towerMovingText),this.towerMovingText=null)}restartGame(){this.health=this.defaultBaseHealth,this.points=0,this.gameOver=!1,this.enemies.forEach((e,t)=>{this.destroyEnemy(t)}),this.enemyIdCounter=0,this.updateHealthDisplay(),this.updatePointsDisplay(),this.gameOverScreen&&(this.gameOverScreen.style.display="none"),this.towerIsMoving=!1,this.resetTowerState(),console.log("Game restarted!")}cleanup(){this.spawnInterval&&clearInterval(this.spawnInterval),this.gameLoop&&cancelAnimationFrame(this.gameLoop),this.enemies.forEach((e,t)=>{this.destroyEnemy(t)})}}const E=new T;window.addEventListener("beforeunload",()=>{E.cleanup()});
